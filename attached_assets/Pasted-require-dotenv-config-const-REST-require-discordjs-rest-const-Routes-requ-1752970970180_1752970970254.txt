require('dotenv').config();

const { REST } = require('@discordjs/rest');
const { Routes } = require('discord-api-types/v10');
const {
  Client,
  GatewayIntentBits,
  SlashCommandBuilder,
  EmbedBuilder,
  PermissionsBitField,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ChannelType,
} = require('discord.js');

const fetch = (...args) => import('node-fetch').then(({ default: fetch }) => fetch(...args));

const TOKEN = process.env.DISCORD_TOKEN;
const CLIENT_ID = process.env.CLIENT_ID;
const GUILD_ID = process.env.GUILD_ID;
const PREFIX = '!';

const GIPHY_API_KEY = process.env.GIPHY_API_KEY;

// --- Función para obtener gif random de Giphy ---
async function getGiphyGif(term) {
  const url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(term)}&limit=10&rating=pg`;
  const res = await fetch(url);
  const { data } = await res.json();
  if (!data || data.length === 0) return null;
  const choice = data[Math.floor(Math.random() * data.length)];
  return choice.images.original.url;
}

// --- Definición de comandos slash ---
const commands = [
  new SlashCommandBuilder()
    .setName('hug')
    .setDescription('Envía un tierno abrazo a alguien 💖')
    .addUserOption(opt => opt.setName('user').setDescription('A quién abrazar').setRequired(true)),

  new SlashCommandBuilder()
    .setName('kiss')
    .setDescription('Envía un dulce beso virtual 💋')
    .addUserOption(opt => opt.setName('user').setDescription('A quién besar').setRequired(true)),

  new SlashCommandBuilder()
    .setName('pat')
    .setDescription('Hazle un tierno pat a alguien 🐾')
    .addUserOption(opt => opt.setName('user').setDescription('A quién hacerle pat').setRequired(true)),

  new SlashCommandBuilder().setName('blush').setDescription('Te sonrojas como un tomate 😳'),
  new SlashCommandBuilder().setName('sleep').setDescription('Te vas a dormir 😴'),
  new SlashCommandBuilder().setName('cry').setDescription('Estás triste y lloras 😢'),

  new SlashCommandBuilder()
    .setName('poke')
    .setDescription('Le haces poke a alguien 👈')
    .addUserOption(opt => opt.setName('user').setDescription('A quién hacerle poke').setRequired(true)),

  new SlashCommandBuilder()
    .setName('snuggle')
    .setDescription('Te acurrucas con alguien 🧸')
    .addUserOption(opt => opt.setName('user').setDescription('A quién acurrucar').setRequired(true)),

const rest = new REST({ version: '10' }).setToken(TOKEN);
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildPresences,
  ],
});

(async () => {
  try {
    await rest.put(Routes.applicationGuildCommands(CLIENT_ID, GUILD_ID), { body: commands });
    console.log('Slash commands registrados.');
  } catch (err) {
    console.error('Error registrando slash commands:', err);
  }
})();

// Comandos por prefijo (ejemplo: hug y kiss)
client.on('messageCreate', async message => {
  if (message.author.bot || !message.content.startsWith(PREFIX)) return;
  const args = message.content.slice(PREFIX.length).trim().split(/ +/);
  const command = args.shift().toLowerCase();
  const target = message.mentions.users.first();

  if (["hug", "kiss"].includes(command)) {
    if (!target) return message.reply(`¡Menciona a alguien! Uso: !${command} @usuario`);
    if (target.id === message.author.id) return message.reply(`¡No puedes ${command} a ti mismo! 🥺`);
    const gifUrl = (await getGiphyGif(`anime ${command}`)) || '';

    const embed = new EmbedBuilder()
      .setTitle(`💫 ¡${command.charAt(0).toUpperCase() + command.slice(1)}!`)
      .setDescription(`${message.author} le da un ${command} a ${target} 💕`)
      .setImage(gifUrl)
      .setColor('#FFC0CB');

    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`accept_${command}_${message.author.id}_${target.id}`)
        .setLabel('Aceptar')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId(`reject_${command}_${message.author.id}_${target.id}`)
        .setLabel('Rechazar')
        .setStyle(ButtonStyle.Danger)
    );

    const sentMessage = await message.channel.send({ embeds: [embed], components: [row] });

    const filter = i =>
      (i.customId.startsWith('accept_') || i.customId.startsWith('reject_')) &&
      i.user.id === target.id;

    const collector = sentMessage.createMessageComponentCollector({ filter, time: 60000 });

    collector.on('collect', async i => {
      const [action, cmd, authorId, targetId] = i.customId.split('_');
      if (action === 'accept') {
        if (cmd === 'kiss') {
          // Ambos se dan un beso y quita botones
          await i.update({
            content: `<@${authorId}> y <@${targetId}> se dieron un beso 💋🥰`,
            embeds: [],
            components: [],
          });
        } else if (cmd === 'hug') {
          // Ambos se dan un abrazo y quita botones
          await i.update({
            content: `<@${authorId}> y <@${targetId}> se dieron un abrazo 🤗💕`,
            embeds: [],
            components: [],
          });
        }
        collector.stop();
      } else if (action === 'reject') {
        // Si rechazan, busca gif "anime slap" y muestra embed con cachetada
        const slapGif = await getGiphyGif('anime slap');

        const embed = new EmbedBuilder()
          .setDescription(`<@${targetId}> le da una cachetada a <@${authorId}> 👋😠`)
          .setColor('#FF0000');

        if (slapGif) embed.setImage(slapGif);

        await i.update({
          content: null,
          embeds: [embed],
          components: [],
        });
        collector.stop();
      }
    });

    collector.on('end', collected => {
      if (collected.size === 0) {
        sentMessage.edit({ content: 'Tiempo agotado, nadie respondió 😔', components: [] });
      }
    });

    return;
  }
});

// Comandos slash interactionCreate
client.on('interactionCreate', async interaction => {
  if (!interaction.isChatInputCommand()) return;
  const { commandName } = interaction;
  const target = interaction.options.getUser('user');

  if (["hug", "kiss"].includes(commandName)) {
    if (!target) return interaction.reply('¡Menciona a alguien!');
    if (target.id === interaction.user.id) return interaction.reply(`¿Te vas a ${commandName} a ti mismo? 😅`);
    const gifUrl = (await getGiphyGif(`anime ${commandName}`)) || '';

    const embed = new EmbedBuilder()
      .setTitle(`💫 ¡${commandName.charAt(0).toUpperCase() + commandName.slice(1)}!`)
      .setDescription(`${interaction.user} le da un ${commandName} a ${target} 💕`)
      .setImage(gifUrl)
      .setColor('#FFC0CB');

    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`accept_${commandName}_${interaction.user.id}_${target.id}`)
        .setLabel('Aceptar')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId(`reject_${commandName}_${interaction.user.id}_${target.id}`)
        .setLabel('Rechazar')
        .setStyle(ButtonStyle.Danger)
    );

    await interaction.reply({ embeds: [embed], components: [row] });

    const message = await interaction.fetchReply();

    const filter = i =>
      (i.customId.startsWith('accept_') || i.customId.startsWith('reject_')) &&
      i.user.id === target.id;

    const collector = message.createMessageComponentCollector({ filter, time: 60000 });

    collector.on('collect', async i => {
      const [action, cmd, authorId, targetId] = i.customId.split('_');
      if (action === 'accept') {
        if (cmd === 'kiss') {
          await i.update({
            content: `<@${authorId}> y <@${targetId}> se dieron un beso 💋🥰`,
            embeds: [],
            components: [],
          });
        } else if (cmd === 'hug') {
          await i.update({
            content: `<@${authorId}> y <@${targetId}> se dieron un abrazo 🤗💕`,
            embeds: [],
            components: [],
          });
        }
        collector.stop();
      } else if (action === 'reject') {
        const slapGif = await getGiphyGif('anime slap');

        const embed = new EmbedBuilder()
          .setDescription(`<@${targetId}> le da una cachetada a <@${authorId}> 👋😠`)
          .setColor('#FF0000');

        if (slapGif) embed.setImage(slapGif);

        await i.update({
          content: null,
          embeds: [embed],
          components: [],
        });
        collector.stop();
      }
    });

    collector.on('end', collected => {
      if (collected.size === 0) {
        message.edit({ content: 'Tiempo agotado, nadie respondió 😔', components: [] });
      }
    });

    return;
  }
